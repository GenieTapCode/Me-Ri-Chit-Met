<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Magic Christmas - Selective Bloom (Heart Tight + More Items) - FIXED PHOTOS</title>

  <!-- Three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Postprocessing deps -->
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
    #canvas-container { width: 100%; height: 100vh; display: block; }

    #ui-layer {
      position: absolute; bottom: 30px; width: 100%;
      text-align: center; pointer-events: none; z-index: 100;
    }
    .guide {
      color: rgba(255,255,255,0.6);
      font-size: 13px; margin-bottom: 20px;
      text-shadow: 0 2px 4px black;
    }
    button {
      pointer-events: auto; cursor: pointer;
      background: linear-gradient(to bottom, #D32F2F, #8B0000);
      color: #FFF; border: 2px solid #FFD700;
      padding: 15px 50px; border-radius: 30px;
      font-weight: 800; font-size: 16px;
      box-shadow: 0 0 30px rgba(255,0,0,0.6);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)} }

    #camera-preview {
      position: absolute; top: 15px; right: 15px;
      width: 240px; height: 180px;
      border: 2px solid rgba(255,0,0,0.5);
      transform: scaleX(-1); opacity: 0.65; border-radius: 8px;
    }

    #copyright {
      position: absolute; bottom: 10px; right: 15px;
      color: rgba(255,255,255,0.3);
      font-size: 12px; z-index: 100;
      pointer-events: none; font-style: italic;
    }

    #error-log {
      display: none;
      position: absolute; top: 10px; left: 10px;
      color: #ff6666; background: rgba(0,0,0,0.75);
      z-index: 999; padding: 10px;
      font-size: 12px; max-width: 560px;
      border: 1px solid rgba(255,100,100,0.4);
      border-radius: 8px; white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="error-log"></div>

  <div id="ui-layer">
    <div class="guide">
      üñê <b>Open:</b> Explode &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|&nbsp; ‚úä <b>Fist:</b> Tree &nbsp;|&nbsp; ü§è <b>Pinch:</b> Photo
    </div>
    <button id="btnStart" onclick="startSystem()">START MAGIC</button>
  </div>

  <div id="copyright">¬© by vandiep</div>

  <div id="canvas-container"></div>
  <video class="input_video" style="display:none"></video>
  <canvas id="camera-preview"></canvas>

  <script>
    // ================= Debug helpers =================
    const errorBox = document.getElementById('error-log');
    function showErr(msg) {
      errorBox.style.display = 'block';
      errorBox.textContent += (msg + "\n");
      console.error(msg);
    }
    window.addEventListener('error', (e) => showErr("JS ERROR: " + (e.message || e.error)));
    window.addEventListener('unhandledrejection', (e) => showErr("PROMISE ERROR: " + (e.reason?.message || e.reason)));

    // ================= Resources =================
    const MUSIC_URL = "./audio.mp3";
    let bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true;
    bgMusic.volume = 1.0;

    const loader = new THREE.TextureLoader();

    // ‚úÖ FIX: add as many photos as you want here (names must match your folder)
    // Example: 10 photos
    const photoFiles = [
      './image1.jpeg','./image2.jpeg','./image3.jpeg','./image4.jpeg','./image5.jpeg',
      './image6.jpeg','./image7.jpeg','./image8.jpeg','./image9.jpeg','./image10.jpeg'
    ];

    const photoTextures = [];
    photoFiles.forEach((f, i) => {
      photoTextures[i] = loader.load(
        f,
        undefined,
        undefined,
        () => showErr("Texture load failed: " + f)
      );
    });

    // ================= Custom textures =================
    function createCustomTexture(type) {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const cx = 64, cy = 64;

      if (type === 'gold_glow') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 44);
        grd.addColorStop(0, 'rgba(255,255,255,1)');
        grd.addColorStop(0.25,'rgba(255,255,224,1)');
        grd.addColorStop(0.55,'rgba(255,215,0,0.95)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

      } else if (type === 'red_light') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 52);
        grd.addColorStop(0, 'rgba(255,200,200,1)');
        grd.addColorStop(0.35,'rgba(255,0,0,0.95)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

      } else if (type === 'gift_red') {
        ctx.fillStyle = '#D32F2F'; ctx.fillRect(20, 20, 88, 88);
        ctx.fillStyle = '#FFD700'; ctx.fillRect(54, 20, 20, 88); ctx.fillRect(20, 54, 88, 20);
        ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth=2; ctx.strokeRect(20,20,88,88);

      } else if (type === 'snow') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 34);
        grd.addColorStop(0, 'rgba(255,255,255,0.95)');
        grd.addColorStop(0.4, 'rgba(255,255,255,0.45)');
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

      } else if (type === 'star') {
        ctx.clearRect(0,0,128,128);
        ctx.shadowColor = 'rgba(255,215,0,0.9)';
        ctx.shadowBlur = 18;
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        const outer=44, inner=18;
        for (let i=0;i<10;i++){
          const ang = (-Math.PI/2) + i*(Math.PI/5);
          const rr = (i%2===0) ? outer : inner;
          ctx.lineTo(cx + Math.cos(ang)*rr, cy + Math.sin(ang)*rr);
        }
        ctx.closePath();
        ctx.fill();

      } else if (type === 'confetti') {
        ctx.clearRect(0,0,128,128);
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0,0,128,128);

        const g = ctx.createLinearGradient(20,20,108,108);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.35, 'rgba(255,215,0,1)');
        g.addColorStop(0.7, 'rgba(255,80,80,1)');
        g.addColorStop(1, 'rgba(120,220,255,1)');
        ctx.fillStyle = g;

        ctx.shadowColor = 'rgba(255,215,0,0.55)';
        ctx.shadowBlur = 10;
        ctx.fillRect(28,28,72,72);

        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 4;
        ctx.strokeRect(28,28,72,72);
      }

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      return tex;
    }

    const textures = {
      gold: createCustomTexture('gold_glow'),
      red:  createCustomTexture('red_light'),
      gift: createCustomTexture('gift_red'),
      snow: createCustomTexture('snow'),
      star: createCustomTexture('star'),
      confetti: createCustomTexture('confetti')
    };

    // ================= Config =================
    const CONFIG = {
      goldCount: 1500,
      redCount: 260,
      giftCount: 120,

      starCount: 280,
      confettiCount: 520,

      snowCount: 420,
      explodeRadius: 65,
      photoOrbitRadius: 25,
      treeHeight: 70,
      treeBaseRadius: 35,

      stateHoldFrames: 3,

      handSpring: 22.0,
      handDamping: 7.5,

      bloomStrength: 0.9,
      bloomRadius: 0.55,
      bloomThreshold: 0.18,

      exposure: 1.0,

      ornamentCount: 160,
      garlandCount: 260,

      heartScale: 2.9,
      heartDepth: 2.6,
      heartNoise: 0.25,
      heartSpeedMult: 1.9
    };

    // ================= Selective Bloom setup =================
    const BLOOM_LAYER = 1;
    const bloomLayer = new THREE.Layers();
    bloomLayer.set(BLOOM_LAYER);

    const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const materials = {};

    function darkenNonBloom(obj) {
      if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
        materials[obj.uuid] = obj.material;
        obj.material = darkMaterial;
      }
    }
    function restoreMaterial(obj) {
      if (materials[obj.uuid]) {
        obj.material = materials[obj.uuid];
        delete materials[obj.uuid];
      }
    }

    // ================= Scene vars =================
    let scene, camera, renderer;
    let composerFinal = null, composerBloom = null, bloomPass = null, finalPass = null;

    let groupGold, groupRed, groupGift, groupSnow, groupStar, groupConfetti;
    let photoMeshes = [];
    let titleMesh, starMesh, loveMesh;

    let ornamentsInstanced = null;
    let garlandPoints = null;

    let state = 'TREE';
    let stateWanted = 'TREE';
    let lastState = 'TREE';
    let stateHold = 0;

    let selectedIndex = 0;

    // hand smoothing with spring
    let handX = 0.5;
    let handXSmooth = 0.5;
    let handVel = 0.0;

    // Reusable vectors (avoid GC)
    const V3A = new THREE.Vector3();
    const V3B = new THREE.Vector3();
    const V3ZERO = new THREE.Vector3(0,0,0);
    const SCALE_TMP = new THREE.Vector3(1,1,1);

    // ================= Three init =================
    function init3D() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 100);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.autoClear = true;

      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = CONFIG.exposure;

      container.appendChild(renderer.domElement);

      // ---------- Create objects ----------
      groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0, THREE.AdditiveBlending);
      groupRed  = createParticleSystem('red',  CONFIG.redCount,  3.2, THREE.AdditiveBlending);
      groupGift = createParticleSystem('gift', CONFIG.giftCount, 2.9, THREE.NormalBlending);

      // new groups (more items)
      groupStar = createParticleSystem('star', CONFIG.starCount, 3.1, THREE.AdditiveBlending);
      groupConfetti = createParticleSystem('confetti', CONFIG.confettiCount, 2.4, THREE.AdditiveBlending);

      groupSnow = createSnowSystem(CONFIG.snowCount);

      // bloom layer for particles / snow / new items
      groupGold.layers.enable(BLOOM_LAYER);
      groupRed.layers.enable(BLOOM_LAYER);
      groupGift.layers.enable(BLOOM_LAYER);
      groupStar.layers.enable(BLOOM_LAYER);
      groupConfetti.layers.enable(BLOOM_LAYER);
      groupSnow.layers.enable(BLOOM_LAYER);

      createPhotos();
      createDecorations();
      createTreeMoreDecor();
      initSelectiveBloom();

      animate();
    }

    // ================= Selective Bloom composers =================
    function initSelectiveBloom() {
      try {
        if (!(THREE.EffectComposer && THREE.RenderPass && THREE.UnrealBloomPass && THREE.ShaderPass)) {
          showErr("Postprocessing scripts missing. Fallback to normal render.");
          composerFinal = null; composerBloom = null;
          return;
        }

        const renderScene = new THREE.RenderPass(scene, camera);

        composerBloom = new THREE.EffectComposer(renderer);
        composerBloom.renderToScreen = false;
        composerBloom.addPass(renderScene);

        bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          CONFIG.bloomStrength,
          CONFIG.bloomRadius,
          CONFIG.bloomThreshold
        );
        composerBloom.addPass(bloomPass);

        composerFinal = new THREE.EffectComposer(renderer);
        composerFinal.addPass(renderScene);

        const finalMat = new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: composerBloom.renderTarget2.texture }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main() {
              vec4 base = texture2D(baseTexture, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        finalPass = new THREE.ShaderPass(finalMat, "baseTexture");
        composerFinal.addPass(finalPass);

      } catch (e) {
        showErr("Selective bloom init failed. Fallback to normal render.\n" + e.message);
        composerFinal = null; composerBloom = null;
      }
    }

    // ================= Particle systems =================
    function createParticleSystem(type, count, size, blendingMode) {
      const pPositions = [];
      const pExplodeTargets = [];
      const pTreeTargets = [];
      const pHeartTargets = [];
      const sizes = [];
      const phases = [];

      for (let i=0; i<count; i++) {
        // TREE
        const h = Math.random() * CONFIG.treeHeight;
        const y = h - CONFIG.treeHeight / 2;
        const radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;
        const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
        const r = maxR * radiusRatio;
        const theta = Math.random() * Math.PI * 2;
        pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

        // EXPLODE
        const u = Math.random(), v = Math.random();
        const phi = Math.acos(2 * v - 1);
        const lam = 2 * Math.PI * u;
        const radMult = (type === 'gift') ? 1.2 : 1.0;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
        pExplodeTargets.push(
          rad * Math.sin(phi) * Math.cos(lam),
          rad * Math.sin(phi) * Math.sin(lam),
          rad * Math.cos(phi)
        );

        // HEART (tighter + solid)
        const tHeart = Math.random() * Math.PI * 2;
        let hx = 16 * Math.pow(Math.sin(tHeart), 3);
        let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);

        const rFill = Math.pow(Math.random(), 0.22);
        hx *= rFill; hy *= rFill;

        let hz = (Math.random() - 0.5) * (CONFIG.heartDepth * 2) * rFill;

        const noise = CONFIG.heartNoise;
        hx += (Math.random() - 0.5) * noise;
        hy += (Math.random() - 0.5) * noise;
        hz += (Math.random() - 0.5) * noise;

        const scaleH = CONFIG.heartScale;
        pHeartTargets.push(hx * scaleH, hy * scaleH + 4, hz);

        // INIT = TREE
        pPositions.push(pTreeTargets[i*3], pTreeTargets[i*3+1], pTreeTargets[i*3+2]);
        sizes.push(size);
        phases.push(Math.random() * Math.PI * 2);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const colors = new Float32Array(count * 3);
      const baseColor = new THREE.Color();

      if (type === 'gold') baseColor.setHex(0xFFD700);
      else if (type === 'red') baseColor.setHex(0xFF0000);
      else if (type === 'gift') baseColor.setHex(0xFFFFFF);
      else if (type === 'star') baseColor.setHex(0xFFE27A);
      else if (type === 'confetti') baseColor.setHex(0xFFFFFF);
      else baseColor.setHex(0xFFFFFF);

      for (let i=0; i<count; i++) {
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      geo.userData = {
        tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets,
        phases, baseColor, baseSize: size
      };

      const mat = new THREE.PointsMaterial({
        size,
        map: textures[type],
        transparent: true,
        opacity: (type === 'confetti') ? 0.88 : 1.0,
        vertexColors: true,
        blending: blendingMode,
        depthWrite: false,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }

    function createSnowSystem(count) {
      const positions = [];
      const speeds = [];
      const phases = [];
      for (let i=0; i<count; i++) {
        positions.push(
          (Math.random() - 0.5) * 220,
          (Math.random() - 0.5) * 160,
          (Math.random() - 0.5) * 220
        );
        speeds.push(0.25 + Math.random() * 0.7);
        phases.push(Math.random() * Math.PI * 2);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.userData = { speeds, phases };

      const mat = new THREE.PointsMaterial({
        size: 1.6,
        map: textures.snow,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const pts = new THREE.Points(geo, mat);
      scene.add(pts);
      return pts;
    }

    // ================= Photos =================
    function createPhotos() {
      const geo = new THREE.PlaneGeometry(8, 8);

      const frameTex = (() => {
        const c = document.createElement('canvas');
        c.width = 256; c.height = 256;
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,256,256);

        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(14,14,228,228);

        ctx.strokeStyle = 'rgba(255,215,0,0.95)';
        ctx.lineWidth = 10;
        ctx.strokeRect(18,18,220,220);

        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(26,40); ctx.lineTo(26,26); ctx.lineTo(40,26);
        ctx.moveTo(216,26); ctx.lineTo(230,26); ctx.lineTo(230,40);
        ctx.moveTo(26,216); ctx.lineTo(26,230); ctx.lineTo(40,230);
        ctx.moveTo(230,216); ctx.lineTo(230,230); ctx.lineTo(216,230);
        ctx.stroke();

        return new THREE.CanvasTexture(c);
      })();

      const borderGeo = new THREE.PlaneGeometry(9.4, 9.4);
      const borderMat = new THREE.MeshBasicMaterial({
        map: frameTex,
        transparent: true,
        blending: THREE.NormalBlending,
        depthWrite: false
      });

      // ‚úÖ FIX #1: loop by photoTextures.length (not 5)
      for (let i=0; i<photoTextures.length; i++) {
        const mat = new THREE.MeshBasicMaterial({
          map: photoTextures[i],
          side: THREE.DoubleSide,
          transparent: false
        });
        const mesh = new THREE.Mesh(geo, mat);

        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = 0.06;
        mesh.add(border);

        mesh.visible = false;
        mesh.scale.set(0,0,0);
        mesh.layers.disable(BLOOM_LAYER);

        scene.add(mesh);
        photoMeshes.push(mesh);
      }
    }

    // ================= Decorations =================
    function createDecorations() {
      // Title
      const canvas = document.createElement('canvas');
      canvas.width = 1024; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.font = 'bold italic 90px "Times New Roman"';
      ctx.fillStyle = '#FFD700';
      ctx.textAlign = 'center';
      ctx.shadowColor = "rgba(255,0,0,0.9)";
      ctx.shadowBlur = 35;
      ctx.fillText("MERRY CHRISTMAS", 512, 130);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
      titleMesh.position.set(0, 50, 0);
      titleMesh.layers.disable(BLOOM_LAYER);
      scene.add(titleMesh);

      // Star top
      const starCanvas = document.createElement('canvas');
      starCanvas.width = 128; starCanvas.height = 128;
      const sCtx = starCanvas.getContext('2d');
      sCtx.fillStyle = "#FFFF00";
      sCtx.shadowColor = "#FFFFFF";
      sCtx.shadowBlur = 18;
      sCtx.beginPath();
      const cx=64, cy=64, outer=50, inner=20;
      for (let i=0; i<5; i++){
        sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
        sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
      }
      sCtx.closePath(); sCtx.fill();

      const starTex = new THREE.CanvasTexture(starCanvas);
      const starMat = new THREE.MeshBasicMaterial({
        map: starTex,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
      starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
      starMesh.layers.disable(BLOOM_LAYER);
      scene.add(starMesh);

      // Love text
      const loveCanvas = document.createElement('canvas');
      loveCanvas.width = 1024; loveCanvas.height = 256;
      const lCtx = loveCanvas.getContext('2d');
      lCtx.font = 'bold 120px "Segoe UI", sans-serif';
      lCtx.fillStyle = '#FF69B4';
      lCtx.textAlign = 'center';
      lCtx.shadowColor = "rgba(255,20,147,0.95)";
      lCtx.shadowBlur = 35;
      lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);

      const loveTex = new THREE.CanvasTexture(loveCanvas);
      const loveMat = new THREE.MeshBasicMaterial({
        map: loveTex,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
      loveMesh.position.set(0, 0, 20);
      loveMesh.visible = false;
      loveMesh.layers.disable(BLOOM_LAYER);
      scene.add(loveMesh);
    }

    // ================= Extra tree decor =================
    function createTreeMoreDecor() {
      const ornGeo = new THREE.IcosahedronGeometry(0.75, 0);
      const ornMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      ornamentsInstanced = new THREE.InstancedMesh(ornGeo, ornMat, CONFIG.ornamentCount);

      const dummy = new THREE.Object3D();
      for (let i=0; i<CONFIG.ornamentCount; i++) {
        const h = Math.random() * (CONFIG.treeHeight * 0.92);
        const y = h - CONFIG.treeHeight / 2;

        const maxR = (1 - (h / CONFIG.treeHeight)) * (CONFIG.treeBaseRadius * 0.92);
        const r = maxR * (0.55 + Math.random() * 0.45);
        const theta = Math.random() * Math.PI * 2;

        dummy.position.set(r * Math.cos(theta), y, r * Math.sin(theta));
        const s = 0.55 + Math.random() * 0.9;
        dummy.scale.set(s,s,s);
        dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
        dummy.updateMatrix();
        ornamentsInstanced.setMatrixAt(i, dummy.matrix);
      }

      ornamentsInstanced.layers.enable(BLOOM_LAYER);
      scene.add(ornamentsInstanced);

      // Garland: spiral points
      const gPos = new Float32Array(CONFIG.garlandCount * 3);
      const gCol = new Float32Array(CONFIG.garlandCount * 3);
      const colA = new THREE.Color(0xffcc66);
      const colB = new THREE.Color(0x66ccff);

      for (let i=0; i<CONFIG.garlandCount; i++) {
        const t = i / (CONFIG.garlandCount - 1);
        const h = t * (CONFIG.treeHeight * 0.92);
        const y = h - CONFIG.treeHeight / 2;

        const maxR = (1 - (h / CONFIG.treeHeight)) * (CONFIG.treeBaseRadius * 0.95);
        const r = maxR * 0.85;
        const theta = t * Math.PI * 10.5;

        gPos[i*3]   = r * Math.cos(theta);
        gPos[i*3+1] = y;
        gPos[i*3+2] = r * Math.sin(theta);

        const cc = (i % 2 === 0) ? colA : colB;
        gCol[i*3] = cc.r; gCol[i*3+1] = cc.g; gCol[i*3+2] = cc.b;
      }

      const gGeo = new THREE.BufferGeometry();
      gGeo.setAttribute('position', new THREE.BufferAttribute(gPos, 3));
      gGeo.setAttribute('color', new THREE.BufferAttribute(gCol, 3));

      const gMat = new THREE.PointsMaterial({
        size: 2.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      garlandPoints = new THREE.Points(gGeo, gMat);
      garlandPoints.layers.enable(BLOOM_LAYER);
      scene.add(garlandPoints);
    }

    function updateTreeDecor(time) {
      if (ornamentsInstanced) {
        const t = 0.5 + 0.5 * Math.sin(time * 3.2);
        ornamentsInstanced.material.color.setRGB(
          0.75 + 0.25*t,
          0.75 + 0.25*Math.sin(time*2.1),
          0.75 + 0.25*Math.cos(time*2.4)
        );
      }
      if (garlandPoints) {
        garlandPoints.rotation.y += 0.0028;
        garlandPoints.material.opacity = 0.75 + 0.2 * Math.sin(time * 2.2);
      }
    }

    function renderFrame() {
      if (composerFinal && composerBloom) {
        scene.traverse(darkenNonBloom);
        composerBloom.render();
        scene.traverse(restoreMaterial);
        composerFinal.render();
        return;
      }
      renderer.render(scene, camera);
    }

    // ================= Animate =================
    let lastT = performance.now();
    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = Math.min(0.033, (now - lastT) / 1000);
      lastT = now;

      const time = now * 0.001;
      const speed = 0.085;

      // spring smoothing
      const x = handXSmooth;
      const v = handVel;
      const k = CONFIG.handSpring;
      const c = CONFIG.handDamping;
      const a = k * (handX - x) - c * v;
      handVel = v + a * dt;
      handXSmooth = x + handVel * dt;

      const handRotY = (handXSmooth - 0.5) * 4.0;

      camera.position.x += (handRotY * 2.2 - camera.position.x) * 0.05;
      camera.position.y += (Math.sin(time * 0.6) * 2.0 - camera.position.y) * 0.03;

      let targetZ = 100;
      if (state === 'EXPLODE') targetZ = 92;
      if (state === 'PHOTO')   targetZ = 85;
      if (state === 'HEART')   targetZ = 95;
      camera.position.z += (targetZ - camera.position.z) * 0.06;
      camera.lookAt(0, 0, 0);

      // particles (include new items)
      updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
      updateParticleGroup(groupRed,  'red',  state, speed, handRotY, time);
      updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);
      updateParticleGroup(groupStar, 'star', state, speed, handRotY, time);
      updateParticleGroup(groupConfetti, 'confetti', state, speed, handRotY, time);

      updateSnow(time);

      // tree decorations should exist ONLY in TREE state
      const treeDecorVisible = (state === 'TREE');
      if (ornamentsInstanced) ornamentsInstanced.visible = treeDecorVisible;
      if (garlandPoints) garlandPoints.visible = treeDecorVisible;
      if (treeDecorVisible) updateTreeDecor(time);

      // decorations / photos
      if (state === 'TREE') {
        titleMesh.visible = true;
        starMesh.visible = true;
        loveMesh.visible = false;

        starMesh.rotation.z -= 0.018;
        starMesh.material.opacity = 0.65 + 0.35 * Math.sin(time * 5);

        for (let i=0; i<photoMeshes.length; i++) {
          const m = photoMeshes[i];
          m.scale.lerp(V3ZERO, 0.18);
          m.visible = false;
        }

      } else if (state === 'HEART') {
        titleMesh.visible = false;
        starMesh.visible = false;
        loveMesh.visible = true;

        const s = 1 + Math.abs(Math.sin(time*3)) * 0.1;
        loveMesh.scale.set(s, s, 1);

        for (let i=0; i<photoMeshes.length; i++) photoMeshes[i].visible = false;

      } else if (state === 'EXPLODE') {
        titleMesh.visible = false;
        starMesh.visible = false;
        loveMesh.visible = false;

        const baseAngle = groupGold.rotation.y;

        // ‚úÖ FIX #2: angleStep depends on photo count (not 5)
        const angleStep = (Math.PI * 2) / Math.max(1, photoMeshes.length);

        let bestIdx = 0, maxZ = -999;

        for (let i=0; i<photoMeshes.length; i++) {
          const mesh = photoMeshes[i];
          mesh.visible = true;

          const angle = baseAngle + i * angleStep;
          const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
          const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
          const y = Math.sin(time + i) * 3;

          V3A.set(x, y, z);
          mesh.position.lerp(V3A, 0.16);
          mesh.lookAt(camera.position);

          if (z > maxZ) { maxZ = z; bestIdx = i; }

          const ds = (z > 5) ? (1.0 + (z/CONFIG.photoOrbitRadius)*0.8) : 0.6;
          SCALE_TMP.set(ds, ds, ds);
          mesh.scale.lerp(SCALE_TMP, 0.16);
        }

        selectedIndex = bestIdx;

      } else if (state === 'PHOTO') {
        loveMesh.visible = false;

        for (let i=0; i<photoMeshes.length; i++) {
          const mesh = photoMeshes[i];
          if (i === selectedIndex) {
            mesh.visible = true;
            V3B.set(0, 0, 60);
            mesh.position.lerp(V3B, 0.18);
            SCALE_TMP.set(5,5,5);
            mesh.scale.lerp(SCALE_TMP, 0.18);
            mesh.lookAt(camera.position);
            mesh.rotation.z = 0;
          } else {
            mesh.scale.lerp(V3ZERO, 0.18);
          }
        }
      }

      renderFrame();
    }

    function updateParticleGroup(group, type, targetState, baseSpeed, handRotY, time) {
      const positions = group.geometry.attributes.position.array;
      const sizesAttr = group.geometry.attributes.size;
      const colorsAttr = group.geometry.attributes.color;

      const sizes = sizesAttr.array;
      const colors = colorsAttr.array;

      const phases = group.geometry.userData.phases;
      const baseColor = group.geometry.userData.baseColor;
      const baseSize = group.geometry.userData.baseSize;

      const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
      const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];

      let speed = baseSpeed;
      if (targetState === 'HEART') speed = Math.min(0.18, baseSpeed * CONFIG.heartSpeedMult);

      for (let i=0; i<positions.length; i++) {
        positions[i] += (targets[i] - positions[i]) * speed;
      }
      group.geometry.attributes.position.needsUpdate = true;

      const count = positions.length / 3;

      if (targetState === 'TREE') {
        group.rotation.y += 0.003;

        for (let i=0; i<count; i++) {
          sizes[i] = baseSize;
          let brightness = 1.0;

          if (type === 'red') brightness = 0.55 + 0.45 * Math.sin(time * 3 + phases[i]);
          else if (type === 'gold') brightness = 0.85 + 0.35 * Math.sin(time * 10 + phases[i]);
          else if (type === 'star') brightness = 0.75 + 0.45 * Math.sin(time * 5 + phases[i]);
          else if (type === 'confetti') brightness = 0.8 + 0.3 * Math.sin(time * 6 + phases[i]);

          colors[i*3]   = baseColor.r * brightness;
          colors[i*3+1] = baseColor.g * brightness;
          colors[i*3+2] = baseColor.b * brightness;
        }
        colorsAttr.needsUpdate = true;
        sizesAttr.needsUpdate = true;

      } else if (targetState === 'HEART') {
        group.rotation.y = 0;

        const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.12;
        group.scale.set(beat, beat, beat);

        for (let i=0; i<count; i++) {
          colors[i*3] = baseColor.r;
          colors[i*3+1] = baseColor.g;
          colors[i*3+2] = baseColor.b;
          sizes[i] = baseSize;
        }
        colorsAttr.needsUpdate = true;
        sizesAttr.needsUpdate = true;

      } else {
        group.scale.set(1,1,1);
        group.rotation.y += (handRotY - group.rotation.y) * 0.14;

        for (let i=0; i<count; i++) {
          sizes[i] = baseSize;
          let brightness = 0.85 + 0.45 * Math.sin(time * 12 + phases[i]);

          colors[i*3]   = baseColor.r * brightness;
          colors[i*3+1] = baseColor.g * brightness;
          colors[i*3+2] = baseColor.b * brightness;
        }
        sizesAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;
      }
    }

    function updateSnow(time) {
      const pos = groupSnow.geometry.attributes.position.array;
      const speeds = groupSnow.geometry.userData.speeds;
      const phases = groupSnow.geometry.userData.phases;

      for (let i=0; i<speeds.length; i++) {
        const idx = i * 3;
        pos[idx]   += Math.sin(time * 0.7 + phases[i]) * 0.02;
        pos[idx+2] += Math.cos(time * 0.6 + phases[i]) * 0.02;

        pos[idx+1] -= speeds[i] * 0.18;
        if (pos[idx+1] < -90) pos[idx+1] = 90;
      }
      groupSnow.geometry.attributes.position.needsUpdate = true;
    }

    // ================= Start System =================
    function startSystem() {
      document.getElementById('btnStart').style.display = 'none';
      bgMusic.play().catch(e => console.log(e));
      init3D();

      const video = document.getElementsByClassName('input_video')[0];
      const canvas = document.getElementById('camera-preview');
      const ctx = canvas.getContext('2d');

      canvas.width = 240;
      canvas.height = 180;

      const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(results => {
        const handsLm = results.multiHandLandmarks || [];
        const w = canvas.width, h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        if (results.image) ctx.drawImage(results.image, 0, 0, w, h);

        stateWanted = 'TREE';

        if (handsLm.length === 2) {
          const h1 = handsLm[0], h2 = handsLm[1];
          const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
          const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
          if (distIndex < 0.15 && distThumb < 0.15) stateWanted = 'HEART';
        }

        if (handsLm.length > 0 && stateWanted !== 'HEART') {
          const lm = handsLm[0];
          handX = lm[9].x;

          const tips = [8,12,16,20];
          const wrist = lm[0];
          let openDist = 0;
          for (let i=0;i<tips.length;i++){
            const idx = tips[i];
            openDist += Math.hypot(lm[idx].x - wrist.x, lm[idx].y - wrist.y);
          }
          const avgDist = openDist / 4;

          const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

          const FIST_TH = 0.24;
          const PINCH_TH = 0.055;

          if (avgDist < FIST_TH) stateWanted = 'TREE';
          else if (pinchDist < PINCH_TH) stateWanted = 'PHOTO';
          else stateWanted = 'EXPLODE';
        }

        if (stateWanted === lastState) {
          stateHold = 0;
        } else {
          stateHold++;
          if (stateHold >= CONFIG.stateHoldFrames) {
            lastState = stateWanted;
            state = stateWanted;
            stateHold = 0;
          }
        }
      });

      const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 320,
        height: 240
      });

      cameraUtils.start().catch(e => showErr("Camera start failed: " + e.message));
    }

    // ================= Resize =================
    window.addEventListener('resize', () => {
      if (!camera || !renderer) return;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composerFinal) composerFinal.setSize(window.innerWidth, window.innerHeight);
      if (composerBloom) composerBloom.setSize(window.innerWidth, window.innerHeight);
      if (bloomPass && bloomPass.setSize) bloomPass.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
